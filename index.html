<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGR Enhanced v3.2 - Dynamic LEO Routing (Fixed)</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow: hidden; background: #0a0e27; }
    #cesiumContainer { width: 100vw; height: 100vh; }

    .panel {
      position: absolute;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);
      color: #e2e8f0;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 0 1px rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }
    #leftPanel { top: 20px; left: 20px; width: 420px; max-height: calc(100vh - 40px); overflow-y: auto; }
    #rightPanel { top: 20px; right: 20px; width: 480px; max-height: calc(100vh - 40px); overflow-y: auto; }
    #bottomPanel { bottom: 20px; left: 50%; transform: translateX(-50%); width: 700px; max-height: 350px; transition: all 0.3s ease; }
    #bottomPanel.collapsed { max-height: 60px; }
    .toggle-header { cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; }
    .toggle-icon { transition: transform 0.3s ease; }
    .toggle-icon.collapsed { transform: rotate(-90deg); }
    .header { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(99, 102, 241, 0.3); }
    h2 { font-size: 22px; font-weight: 700; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 8px; letter-spacing: -0.5px; }
    .subtitle { font-size: 12px; color: #94a3b8; font-weight: 500; text-transform: uppercase; letter-spacing: 0.8px; }
    h3 { margin: 25px 0 15px 0; font-size: 15px; color: #cbd5e1; text-transform: uppercase; letter-spacing: 1px; font-weight: 600; border-left: 3px solid #6366f1; padding-left: 10px; }
    .section { background: rgba(30, 41, 59, 0.4); padding: 16px; border-radius: 10px; margin-bottom: 16px; border: 1px solid rgba(100, 116, 139, 0.15); transition: all 0.3s ease; }
    .section:hover { background: rgba(30, 41, 59, 0.6); border-color: rgba(99, 102, 241, 0.3); }
    label { display: block; margin-bottom: 10px; font-size: 13px; color: #cbd5e1; font-weight: 500; }

    input[type="range"] { width: 100%; height: 8px; border-radius: 4px; background: linear-gradient(to right, #6366f1 0%, #6366f1 var(--value), rgba(148,163,184,0.2) var(--value), rgba(148,163,184,0.2) 100%); outline: none; margin: 10px 0; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); cursor: pointer; box-shadow: 0 4px 12px rgba(99, 102, 241, 0.5); transition: transform 0.2s; }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

    input[type="number"], select {
      width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(100, 116, 139, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 14px; font-family: 'SF Mono', 'Menlo', monospace; transition: all 0.3s;
    }
    input[type="number"]:focus, select:focus { outline: none; border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }

    button {
      width: 100%; padding: 14px; margin: 8px 0; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s; box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4); position: relative; overflow: hidden;
    }
    button::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%); transform: translateX(-100%); transition: transform 0.3s; }
    button:hover::before { transform: translateX(0); }
    button:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.6); }
    button:active { transform: translateY(0); }
    button.secondary { background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.8) 100%); box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3); }

    .value-badge { display: inline-block; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); padding: 4px 12px; border-radius: 8px; margin-left: 10px; font-weight: 700; font-size: 13px; font-family: 'SF Mono', 'Menlo', monospace; box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3); }
    .metric-card { background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(51, 65, 85, 0.7) 100%); padding: 16px 18px; border-radius: 12px; margin: 12px 0; border-left: 4px solid #6366f1; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.3s; }
    .metric-card:hover { transform: translateX(5px); border-left-color: #a855f7; }
    .metric-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; }
    .metric-label { color: #94a3b8; font-size: 13px; font-weight: 500; }
    .metric-value { color: #e2e8f0; font-weight: 700; font-size: 17px; font-family: 'SF Mono', 'Menlo', monospace; }
    .metric-value.highlight { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 20px; }
    .contact-window { background: rgba(30, 41, 59, 0.6); padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 3px solid #10b981; font-size: 12px; transition: all 0.3s; }
    .contact-window:hover { background: rgba(30, 41, 59, 0.8); transform: translateX(3px); }
    .contact-window.active { border-left-color: #22c55e; background: rgba(34, 197, 94, 0.15); box-shadow: 0 0 20px rgba(34, 197, 94, 0.3); }
    .route-step { background: rgba(99, 102, 241, 0.15); padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 3px solid #6366f1; font-size: 13px; }

    .status-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 10px; animation: pulse 2s ease-in-out infinite; box-shadow: 0 0 10px currentColor; }
    .status-indicator.active { background: #22c55e; color: #22c55e; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }

    .algo-info { background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); padding: 14px; border-radius: 10px; margin: 12px 0; font-size: 12px; line-height: 1.7; }

    .legend-box { background: rgba(30, 41, 59, 0.5); padding: 14px; border-radius: 8px; margin: 15px 0; border: 1px solid rgba(100, 116, 139, 0.2); }
    .legend-item { display: flex; align-items: center; margin: 8px 0; font-size: 12px; }
    .legend-color { width: 16px; height: 16px; border-radius: 50%; margin-right: 10px; border: 2px solid white; }
    .legend-color.source { background: #22c55e; }
    .legend-color.destination { background: #ef4444; }
    .legend-color.normal { background: #06b6d4; }

    .collision-warning { background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; padding: 12px; border-radius: 8px; margin: 8px 0; font-size: 12px; animation: warning-pulse 2s ease-in-out infinite; }
    @keyframes warning-pulse { 0%, 100% { background: rgba(239, 68, 68, 0.2); } 50% { background: rgba(239, 68, 68, 0.4); } }
    .collision-safe { background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; padding: 12px; border-radius: 8px; margin: 8px 0; font-size: 12px; }

    .tab-container { display: flex; gap: 8px; margin-bottom: 16px; }
    .tab { flex: 1; padding: 10px; background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(100, 116, 139, 0.2); border-radius: 8px; cursor: pointer; text-align: center; font-size: 12px; font-weight: 600; transition: all 0.3s; }
    .tab:hover { background: rgba(30, 41, 59, 0.8); }
    .tab.active { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); border-color: #6366f1; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: rgba(30, 41, 59, 0.5); border-radius: 5px; }
    ::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #a855f7 0%, #6366f1 100%); }

    .badge-new { background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%); color: white; padding: 3px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; margin-left: 8px; animation: blink 2s ease-in-out infinite; }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

    .sim-time {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.95); color: #e2e8f0; padding: 10px 20px; border-radius: 8px;
      font-family: 'SF Mono', monospace; font-size: 14px; border: 1px solid rgba(99, 102, 241, 0.3);
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- Simulation Time Display -->
  <div class="sim-time">Simulation Time: <span id="simTimeDisplay">0.0</span> s</div>

  <!-- Left Panel -->
  <div id="leftPanel" class="panel">
    <div class="header">
      <h2>Advanced Configuration</h2>
      <div class="subtitle">CGR Enhanced v3.2 <span class="badge-new">OPTIMIZED</span></div>
    </div>

    <div class="section">
      <label>Number of Satellites: <span class="value-badge" id="satCountDisplay">27</span></label>
      <input type="range" id="satCount" min="9" max="36" value="27" step="9" style="--value: 67%">
    </div>

    <div class="section">
      <label>Orbital Altitude (km): <span class="value-badge" id="altDisplay">600</span></label>
      <input type="range" id="altitude" min="400" max="1200" value="600" step="50" style="--value: 25%">
    </div>

    <div class="section">
      <label>Simulation Speed: <span class="value-badge" id="speedDisplay">20x</span></label>
      <input type="range" id="simSpeed" min="1" max="100" value="20" step="1" style="--value: 20%">
    </div>

    <h3>CGR Algorithm <span class="badge-new">AUTO-ADAPTIVE</span></h3>

    <div class="section">
      <label>Routing Mode:</label>
      <select id="routingAlgorithm">
        <option value="cgr-classic">CGR Classic</option>
        <option value="cgr-enhanced" selected>CGR Enhanced (Optimized)</option>
        <option value="auto">Auto (Best Performance)</option>
      </select>
    </div>

    <div class="algo-info">
      <strong>Enhanced Mode:</strong> Optimized CGR with quality-aware routing, intelligent pruning, and automatic fallback for maximum reliability.
    </div>

    <div class="section">
      <label>Recalculation Frequency (s): <span class="value-badge" id="recalcDisplay">3</span></label>
      <input type="range" id="recalcFreq" min="1" max="10" value="3" step="1" style="--value: 22%">
    </div>

    <div class="section">
      <label>Planning Horizon (min):</label>
      <input type="number" id="planningHorizon" value="30" min="5" max="180" step="5">
    </div>

    <div class="section">
      <label>Bundle Size (MB):</label>
      <input type="number" id="bundleSize" value="2" min="1" max="500" step="1">
    </div>

    <h3>Alternative Routes</h3>
    <div class="section">
      <label>K Routes (Yen's Algorithm): <span class="value-badge" id="kDisplay">3</span></label>
      <input type="range" id="kRoutes" min="1" max="10" value="3" step="1" style="--value: 22%">
    </div>

    <div class="legend-box">
      <div class="legend-item"><div class="legend-color source"></div><span><strong>Green:</strong> Source Node</span></div>
      <div class="legend-item"><div class="legend-color destination"></div><span><strong>Red:</strong> Destination Node</span></div>
      <div class="legend-item"><div class="legend-color normal"></div><span><strong>Cyan:</strong> Regular Satellite</span></div>
    </div>

    <button onclick="changeSenderReceiver()">üîÑ Change Source & Destination</button>
    <button onclick="toggleAnimation()" class="secondary">‚èØÔ∏è Play/Pause</button>
    <button onclick="resetView()" class="secondary">üè† Reset View</button>
  </div>

  <!-- Right Panel -->
  <div id="rightPanel" class="panel">
    <div class="header">
      <h2>Real-time Metrics</h2>
      <div class="subtitle">System Performance</div>
    </div>

    <div class="metric-card">
      <div class="status-indicator active"></div>
      <strong>Active Algorithm:</strong> <span id="activeAlgo">CGR Enhanced</span>
    </div>

    <div class="metric-card">
      <div class="metric-row"><span class="metric-label">Active Links:</span><span class="metric-value highlight" id="activeContacts">0</span></div>
      <div class="metric-row"><span class="metric-label">Last Recalculation:</span><span class="metric-value" id="lastRecalc">-</span></div>
      <div class="metric-row"><span class="metric-label">Calculation Time:</span><span class="metric-value" id="calcTime">-</span></div>
    </div>

    <h3>Collision Detection</h3>
    <div class="section">
      <label>Minimum Safe Distance (km):</label>
      <input type="number" id="safeDistance" value="2" min="1" max="50" step="1">
    </div>
    <div id="collisionStatus"></div>

    <h3>Active Route</h3>
    <div class="metric-card">
      <div class="metric-row"><span class="metric-label">E2E Latency:</span><span class="metric-value highlight" id="routeLatency">-</span></div>
      <div class="metric-row"><span class="metric-label">Total Hops:</span><span class="metric-value" id="routeHops">-</span></div>
    </div>

    <h3>Alternative K-Yen Routes</h3>
    <div id="alternativeRoutes" style="max-height: 180px; overflow-y: auto;"></div>
  </div>

  <!-- Bottom Panel -->
  <div id="bottomPanel" class="panel collapsed">
    <div class="header toggle-header" onclick="toggleBottomPanel()">
      <div>
        <h2>System Information</h2>
        <div class="subtitle">Contact Windows & Collision Alerts</div>
      </div>
      <span class="toggle-icon collapsed">‚ñº</span>
    </div>
    <div class="collapsible-content" id="contactWindowsContent" style="max-height: 0; overflow: hidden;">
      <div class="tab-container">
        <div class="tab active" onclick="switchTab('contacts')">Contact Windows</div>
        <div class="tab" onclick="switchTab('collisions')">Collision Alerts</div>
      </div>

      <div id="contactsTab" class="tab-content active"><div id="contactWindows" style="max-height: 240px; overflow-y: auto;"></div></div>
      <div id="collisionsTab" class="tab-content"><div id="collisionsList" style="max-height: 240px; overflow-y: auto;"></div></div>
    </div>
  </div>

  <script>
    // =============== CESIUM INITIALIZATION ===============
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5N2UyMjcwOS00MDY1LTQxYjEtYjZjMy00YTU0ZTg1YmJhMzEiLCJpZCI6ODAzMDYsImlhdCI6MTY0Mjc0ODI2MX0.dkwAL1CcljUV7NA7fDbhXXnmyZQU_c-G5zRx8PtEcxE';

    const viewer = new Cesium.Viewer('cesiumContainer', {
      imageryProvider: new Cesium.TileMapServiceImageryProvider({
        url: Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII')
      }),
      baseLayerPicker: false,
      geocoder: false,
      homeButton: false,
      sceneModePicker: false,
      timeline: true,
      animation: true,
      navigationHelpButton: false,
      fullscreenButton: false
    });

    viewer.scene.globe.enableLighting = true;
    viewer.scene.globe.atmosphereLightIntensity = 3.0;
    viewer.scene.globe.showGroundAtmosphere = true;

    // =============== CONSTANTS ===============
    const EARTH_RADIUS = 6_371_000; // meters
    const GM = 3.986004418e14; // m^3/s^2 (no imprescindible para la animaci√≥n simple)
    const C = 299_792_458; // speed of light (m/s)

    // =============== STATE ===============
    let satellites = [];      // array de { id, plane, index, meanAnomalyStart, inclination, raan, entity }
    let contactGraph = [];    // array de contactos (aristas temporales)
    let currentRoute = null;
    let linkEntities = [];    // enlaces activos dibujados
    let routeEntities = [];   // ruta activa dibujada
    let collisionWarnings = [];
    let activeTab = 'contacts';

    let sourceNode = null;
    let destNode = null;

    // M√©tricas
    let lastRecalcTime = 0;
    let performanceStats = { classic: 0, enhanced: 0 };

    // =============== CONFIG ===============
    let config = {
      satCount: 27,
      altitude: 600_000,         // meters
      simSpeed: 20,
      planningHorizon: 30 * 60,  // seconds
      bundleSize: 2 * 1e6,       // bytes
      routingAlgorithm: 'cgr-enhanced',
      kRoutes: 3,
      safeDistance: 2_000,       // meters
      recalcFreq: 3              // seconds
    };

    // =============== CLOCK (√öNICA FUENTE DE TIEMPO) ===============
    const startJD = Cesium.JulianDate.now();
    const stopJD  = Cesium.JulianDate.addDays(startJD, 1, new Cesium.JulianDate());
    viewer.clock.startTime   = startJD.clone();
    viewer.clock.stopTime    = stopJD.clone();
    viewer.clock.currentTime = startJD.clone();
    viewer.clock.clockRange  = Cesium.ClockRange.LOOP_STOP;
    viewer.clock.multiplier  = config.simSpeed;
    viewer.clock.shouldAnimate = true;

    function simSeconds() {
      return Cesium.JulianDate.secondsDifference(viewer.clock.currentTime, viewer.clock.startTime);
    }

    // =============== UI HELPERS ===============
    function toggleBottomPanel() {
      const panel = document.getElementById('bottomPanel');
      const content = document.getElementById('contactWindowsContent');
      const icon = document.querySelector('.toggle-icon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        content.style.maxHeight = '280px';
        icon.classList.remove('collapsed');
      } else {
        panel.classList.add('collapsed');
        content.style.maxHeight = '0';
        icon.classList.add('collapsed');
      }
    }

    function switchTab(tabName) {
      activeTab = tabName;
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      if (tabName === 'contacts') {
        document.querySelector('.tab:nth-child(1)').classList.add('active');
        document.getElementById('contactsTab').classList.add('active');
      } else {
        document.querySelector('.tab:nth-child(2)').classList.add('active');
        document.getElementById('collisionsTab').classList.add('active');
      }
    }

    function updateDisplayBadges() {
      document.getElementById('satCountDisplay').textContent = config.satCount;
      document.getElementById('altDisplay').textContent = Math.round(config.altitude/1000);
      document.getElementById('speedDisplay').textContent = `${config.simSpeed}x`;
      document.getElementById('recalcDisplay').textContent = config.recalcFreq;
      document.getElementById('kDisplay').textContent = config.kRoutes;
    }

    // =============== ORBIT & POSITIONS ===============
    // Animaci√≥n simplificada con per√≠odo artificial (para ver movimiento suave)
    const ORBITAL_PERIOD_SIM = 6000; // s

    function getSatellitePosition(plane, satIndex, meanAnomalyStart, inclination, raan, tSec) {
      const meanMotion = (2 * Math.PI) / ORBITAL_PERIOD_SIM;
      const meanAnomalyDeg = meanAnomalyStart + (meanMotion * tSec * 180 / Math.PI);

      const a = EARTH_RADIUS + config.altitude;
      const incRad = Cesium.Math.toRadians(inclination);
      const raanRad = Cesium.Math.toRadians(raan);
      const maRad = Cesium.Math.toRadians(meanAnomalyDeg);

      const x = a * (Math.cos(raanRad) * Math.cos(maRad) - Math.sin(raanRad) * Math.sin(maRad) * Math.cos(incRad));
      const y = a * (Math.sin(raanRad) * Math.cos(maRad) + Math.cos(raanRad) * Math.sin(maRad) * Math.cos(incRad));
      const z = a * Math.sin(maRad) * Math.sin(incRad);

      return new Cesium.Cartesian3(x, y, z);
    }

    function addSatelliteEntity(sat) {
      const color =
        (sourceNode && sat.id === sourceNode.id) ? Cesium.Color.LIME :
        (destNode && sat.id === destNode.id) ? Cesium.Color.RED :
        Cesium.Color.CYAN;

      sat.entity = viewer.entities.add({
        name: `SAT-${sat.id}`,
        position: new Cesium.CallbackProperty(() => {
          const t = simSeconds();
          return getSatellitePosition(sat.plane, sat.index, sat.meanAnomalyStart, sat.inclination, sat.raan, t);
        }, false),
        point: { pixelSize: 8, color: color, outlineWidth: 2, outlineColor: Cesium.Color.WHITE },
        label: {
          text: `S${sat.id}`,
          font: '12px monospace',
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          pixelOffset: new Cesium.Cartesian2(0, -18),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        }
      });
    }

    function clearSatellites() {
      satellites.forEach(s => { if (s.entity) viewer.entities.remove(s.entity); });
      satellites = [];
    }

    function initConstellation(satCount, altitude) {
      clearSatellites();

      const planes = Math.max(1, Math.round(satCount / 9)); // p.ej., 27 => 3 planos
      const satsPerPlane = Math.round(satCount / planes);
      const baseInclination = 53; // grados
      const raanStep = 360 / planes;

      let idCounter = 1;

      for (let p = 0; p < planes; p++) {
        const raan = (p * raanStep) % 360;
        for (let s = 0; s < satsPerPlane; s++) {
          const meanAnomalyStart = (s * 360 / satsPerPlane) % 360;
          const sat = {
            id: idCounter++,
            plane: p,
            index: s,
            meanAnomalyStart,
            inclination: baseInclination + (p % 2 === 0 ? 0 : 5), // un poco de variaci√≥n
            raan,
            entity: null
          };
          satellites.push(sat);
        }
      }

      // Ajusta exacto a satCount
      satellites = satellites.slice(0, satCount);
      satellites.forEach(addSatelliteEntity);

      // Pick default source/destination si no existen
      if (!sourceNode) sourceNode = satellites[0];
      if (!destNode) destNode = satellites[satellites.length - 1];
      recolorSourceDest();
    }

    function recolorSourceDest() {
      satellites.forEach(sat => {
        if (!sat.entity) return;
        const mat =
          (sourceNode && sat.id === sourceNode.id) ? Cesium.Color.LIME :
          (destNode && sat.id === destNode.id) ? Cesium.Color.RED :
          Cesium.Color.CYAN;
        sat.entity.point.color = mat;
      });
    }

    // =============== CONTACT WINDOWS & GRAPH ===============
    function calculateLinkQuality(distance, sat1, sat2) {
      const maxDist = 5_500_000; // 5500 km
      const distanceFactor = Math.max(0, 1 - (distance / maxDist)); // 0..1
      const planeDiversity = Math.abs(sat1.plane - sat2.plane) / 2;
      const altitudeFactor = config.altitude < 600_000 ? 0.85 : 1.0;
      const q = (distanceFactor * 0.6 + planeDiversity * 0.2 + altitudeFactor * 0.2);
      return Math.max(0.05, Math.min(1, q));
    }

    function findOptimalContactWindows(s1, s2, startTime, endTime) {
      const windows = [];
      const timeStep = 30;                // seconds
      const maxDistance = 5_500_000;      // meters
      let inContact = false;
      let windowStart = null;
      let bestDistance = Infinity;

      for (let t = startTime; t <= endTime; t += timeStep) {
        const p1 = getSatellitePosition(s1.plane, s1.index, s1.meanAnomalyStart, s1.inclination, s1.raan, t);
        const p2 = getSatellitePosition(s2.plane, s2.index, s2.meanAnomalyStart, s2.inclination, s2.raan, t);
        const d  = Cesium.Cartesian3.distance(p1, p2);

        if (d <= maxDistance && !inContact) {
          inContact = true; windowStart = t; bestDistance = d;
        } else if (inContact) {
          if (d < bestDistance) bestDistance = d;
          if (d > maxDistance || t === endTime) {
            inContact = false;
            if (windowStart !== null && (t - windowStart) > 30) {
              windows.push({
                start: windowStart,
                end: t,
                distance: bestDistance,
                quality: calculateLinkQuality(bestDistance, s1, s2)
              });
            }
          }
        }
      }
      return windows;
    }

    function buildContactGraph() {
      const t0 = simSeconds();
      const t1 = t0 + config.planningHorizon;
      contactGraph = [];

      // Limpia enlaces visuales previos
      linkEntities.forEach(e => viewer.entities.remove(e));
      linkEntities = [];

      for (let i = 0; i < satellites.length; i++) {
        for (let j = i + 1; j < satellites.length; j++) {
          const s1 = satellites[i], s2 = satellites[j];
          const wins = findOptimalContactWindows(s1, s2, t0, t1);
          wins.forEach((w, k) => {
            const owlt = w.distance / C; // one-way light time
            const setup_s = 0.2 + (1 - w.quality) * 0.6; // peque√±o overhead dependiente de calidad
            const type = (config.altitude < 600_000 && w.distance < 3_000_000) ? 'optical' : 'rf';

            // id √∫nico estable
            const idF = `C_${s1.id}_${s2.id}_${Math.round(w.start)}`;
            const idB = `C_${s2.id}_${s1.id}_${Math.round(w.start)}`;

            contactGraph.push({
              id: idF, from: s1.id, to: s2.id,
              t_start: w.start, t_end: w.end,
              owlt, setup_s, type, quality: w.quality
            });
            contactGraph.push({
              id: idB, from: s2.id, to: s1.id,
              t_start: w.start, t_end: w.end,
              owlt, setup_s, type, quality: w.quality
            });

            // Dibuja enlace (callback para que se mueva)
            const ent = viewer.entities.add({
              polyline: {
                positions: new Cesium.CallbackProperty(() => {
                  const t = simSeconds();
                  const p1 = getSatellitePosition(s1.plane, s1.index, s1.meanAnomalyStart, s1.inclination, s1.raan, t);
                  const p2 = getSatellitePosition(s2.plane, s2.index, s2.meanAnomalyStart, s2.inclination, s2.raan, t);
                  return [p1, p2];
                }, false),
                width: 1.0,
                material: Cesium.Color.fromCssColorString(type === 'optical' ? '#a855f7' : '#06b6d4').withAlpha(0.25)
              }
            });
            linkEntities.push(ent);
          });
        }
      }

      updateContactWindowsList();
    }

    function updateContactWindowsList() {
      const list = document.getElementById('contactWindows');
      list.innerHTML = '';
      const nowSec = simSeconds();
      // Muestra 10 ventanas activas o pr√≥ximas
      const soon = contactGraph
        .filter(c => c.t_end >= nowSec)
        .sort((a, b) => a.t_start - b.t_start)
        .slice(0, 10);

      soon.forEach(c => {
        const div = document.createElement('div');
        div.className = 'contact-window';
        const active = nowSec >= c.t_start && nowSec < c.t_end;
        if (active) div.classList.add('active');
        div.innerHTML = `
          <div class="contact-info"><span class="contact-label"><strong>${c.from} ‚Üí ${c.to}</strong></span><span class="contact-value">${c.type.toUpperCase()}</span></div>
          <div class="contact-info"><span class="contact-label">Start:</span><span class="contact-value">${(c.t_start - nowSec).toFixed(0)} s</span></div>
          <div class="contact-info"><span class="contact-label">End:</span><span class="contact-value">${(c.t_end - nowSec).toFixed(0)} s</span></div>
          <div class="contact-info"><span class="contact-label">OWLT:</span><span class="contact-value">${(c.owlt*1000).toFixed(1)} ms</span></div>
          <div class="contact-info"><span class="contact-label">Q:</span><span class="contact-value">${(c.quality).toFixed(2)}</span></div>
        `;
        list.appendChild(div);
      });
    }

    // =============== COLLISION DETECTION ===============
    function detectCollisions() {
      collisionWarnings = [];
      const safeKm = config.safeDistance / 1000;
      const t = simSeconds();

      for (let i = 0; i < satellites.length; i++) {
        for (let j = i + 1; j < satellites.length; j++) {
          const a = satellites[i], b = satellites[j];
          const p1 = getSatellitePosition(a.plane, a.index, a.meanAnomalyStart, a.inclination, a.raan, t);
          const p2 = getSatellitePosition(b.plane, b.index, b.meanAnomalyStart, b.inclination, b.raan, t);
          const dKm = Cesium.Cartesian3.distance(p1, p2) / 1000;
          if (dKm < safeKm) {
            collisionWarnings.push({
              sat1: `SAT-${a.id}`,
              sat2: `SAT-${b.id}`,
              distance: dKm.toFixed(2),
              riskLevel: dKm < safeKm / 2 ? 'CRITICAL' : 'HIGH'
            });
          }
        }
      }
      updateCollisionDisplay();
    }

    function updateCollisionDisplay() {
      const statusDiv = document.getElementById('collisionStatus');
      const listDiv = document.getElementById('collisionsList');
      if (collisionWarnings.length === 0) {
        statusDiv.innerHTML = `<div class="collision-safe"><strong>‚úì Status: SAFE</strong><br>No collision risks detected</div>`;
        listDiv.innerHTML = '<p style="text-align:center; color:#94a3b8;">No active collision alerts</p>';
      } else {
        statusDiv.innerHTML = `<div class="collision-warning"><strong>‚ö†Ô∏è COLLISION WARNING</strong><br>${collisionWarnings.length} potential risk(s) detected</div>`;
        listDiv.innerHTML = '';
        collisionWarnings.forEach(w => {
          const div = document.createElement('div');
          div.className = 'contact-window';
          div.style.borderLeftColor = w.riskLevel === 'CRITICAL' ? '#ef4444' : '#f59e0b';
          div.innerHTML = `
            <div class="contact-info"><span class="contact-label"><strong>${w.sat1} - ${w.sat2}</strong></span><span class="contact-value" style="color:${w.riskLevel==='CRITICAL'?'#ef4444':'#f59e0b'}">${w.riskLevel}</span></div>
            <div class="contact-info"><span class="contact-label">Distance:</span><span class="contact-value">${w.distance} km</span></div>
          `;
          listDiv.appendChild(div);
        });
      }
    }

    // =============== CGR CLASSIC & ENHANCED ===============
    function cgrClassicSearch(srcId, dstId, t0, bundle_bytes) {
      const distances = {};
      const arrivalTimes = {};
      const previous = {};
      const unvisited = new Set();
      const contacts = contactGraph;

      for (let i = 0; i < contacts.length; i++) {
        distances[i] = Infinity;
        arrivalTimes[i] = t0;
        previous[i] = null;
        unvisited.add(i);
      }

      // Inicializa contactos desde src
      contacts.forEach((c, idx) => {
        if (c.from === srcId && c.t_start <= t0 && c.t_end > t0) {
          const eta = t0 + c.owlt + c.setup_s;
          if (eta <= c.t_end) {
            distances[idx] = eta - t0;
            arrivalTimes[idx] = eta;
          }
        }
      });

      let best_end = null;
      let best_eta = Infinity;

      while (unvisited.size > 0) {
        let current_idx = null;
        let min_dist = Infinity;
        unvisited.forEach(idx => {
          if (distances[idx] < min_dist) { min_dist = distances[idx]; current_idx = idx; }
        });
        if (current_idx === null || min_dist === Infinity) break;
        unvisited.delete(current_idx);

        const current = contacts[current_idx];
        if (current.to === dstId) {
          best_end = current_idx;
          best_eta = arrivalTimes[current_idx];
          break;
        }

        contacts.forEach((n, nj) => {
          if (!unvisited.has(nj)) return;
          if (n.from !== current.to) return;
          if (n.t_start > arrivalTimes[current_idx]) return;
          if (n.t_end <= arrivalTimes[current_idx]) return;
          const eta_n = arrivalTimes[current_idx] + n.owlt + n.setup_s;
          if (eta_n > n.t_end) return;

          const new_dist = eta_n - t0;
          if (new_dist < distances[nj]) {
            distances[nj] = new_dist;
            arrivalTimes[nj] = eta_n;
            previous[nj] = current_idx;
          }
        });
      }

      if (best_end === null) return { found: false };

      const path = [];
      const nodes = [dstId];
      let cur = best_end;
      while (cur !== null) {
        path.unshift(contacts[cur].id);
        if (previous[cur] !== null) nodes.unshift(contacts[cur].from);
        cur = previous[cur];
      }
      return { found: true, eta: best_eta, latency: best_eta - t0, hops: path.length, contact_ids: path, nodes };
    }

    function cgrEnhancedInternal(srcId, dstId, t0, bundle_bytes) {
      const contacts = contactGraph;
      const distances = {};
      const arrivalTimes = {};
      const previous = {};
      const nodeQuality = {};
      const unvisited = new Set();

      for (let i = 0; i < contacts.length; i++) {
        distances[i] = Infinity;
        arrivalTimes[i] = t0;
        previous[i] = null;
        nodeQuality[i] = contacts[i].quality || 1.0;
        unvisited.add(i);
      }

      // Selecci√≥n inicial con calidad
      contacts.forEach((c, idx) => {
        if (c.from !== srcId) return;
        if (c.t_start > t0 || c.t_end <= t0) return;
        const eta = t0 + c.owlt + c.setup_s;
        if (eta > c.t_end) return;
        const weighted = (eta - t0) * (2.0 - (c.quality || 1));
        distances[idx] = weighted;
        arrivalTimes[idx] = eta;
      });

      let best_end = null;
      let best_eta = Infinity;
      let iterations = 0;
      const maxIterations = contacts.length * 2;

      while (unvisited.size > 0 && iterations < maxIterations) {
        iterations++;
        let current_idx = null;
        let min_eff = Infinity;

        unvisited.forEach(idx => {
          const qBoost = nodeQuality[idx] * 0.9;
          const eff = distances[idx] * qBoost;
          if (eff < min_eff) { min_eff = eff; current_idx = idx; }
        });

        if (current_idx === null || distances[current_idx] === Infinity) break;
        unvisited.delete(current_idx);

        const current = contacts[current_idx];
        if (current.to === dstId) {
          best_end = current_idx;
          best_eta = arrivalTimes[current_idx];
          break;
        }

        contacts.forEach((n, nj) => {
          if (!unvisited.has(nj)) return;
          if (n.from !== current.to) return;
          if (n.t_start > arrivalTimes[current_idx]) return;
          if (n.t_end <= arrivalTimes[current_idx]) return;

          let effective_setup = n.setup_s;
          const qDiff = Math.abs((current.quality || 1) - (n.quality || 1));
          effective_setup += qDiff * 0.2;
          if (config.altitude < 600_000 && n.type === 'optical') effective_setup *= 0.8;

          const eta_n = arrivalTimes[current_idx] + n.owlt + effective_setup;
          if (eta_n > n.t_end) return;

          const new_dist = (eta_n - t0) * (2.0 - (n.quality || 1));
          if (new_dist < distances[nj]) {
            distances[nj] = new_dist;
            arrivalTimes[nj] = eta_n;
            previous[nj] = current_idx;
            nodeQuality[nj] = (nodeQuality[current_idx] + (n.quality || 1)) / 2;
          }
        });
      }

      if (best_end === null) return { found: false };

      const path = [];
      const nodes = [dstId];
      let cur = best_end;
      while (cur !== null) {
        path.unshift(contacts[cur].id);
        if (previous[cur] !== null) nodes.unshift(contacts[cur].from);
        cur = previous[cur];
      }
      return { found: true, eta: best_eta, latency: best_eta - t0, hops: path.length, contact_ids: path, nodes };
    }

    function cgrEnhancedSearch(srcId, dstId, t0, bundle_bytes) {
      // 1) Enhanced
      let result = cgrEnhancedInternal(srcId, dstId, t0, bundle_bytes);

      // 2) Ampliar horizonte si falla
      if (!result.found) {
        const oldH = config.planningHorizon;
        config.planningHorizon = Math.max(oldH, 60 * 60);
        buildContactGraph();
        result = cgrEnhancedInternal(srcId, dstId, t0, bundle_bytes);
        config.planningHorizon = oldH;
        buildContactGraph(); // restablece grafo al horizonte original
      }

      // 3) Fallback a Classic
      if (!result.found) {
        result = cgrClassicSearch(srcId, dstId, t0, bundle_bytes);
      }

      // 4) √öltimo recurso: fuerza enlace directo m√°s corto en el intervalo (garantiza ruta)
      if (!result.found) {
        const t1 = t0 + config.planningHorizon;
        let best = null;
        contactGraph.forEach(c => {
          if (c.from === srcId && c.to === dstId && c.t_end > t0 && c.t_start <= t1) {
            const start = Math.max(t0, c.t_start);
            const eta = start + c.owlt + c.setup_s;
            if (eta <= c.t_end) {
              const lat = eta - t0;
              if (!best || lat < best.latency) {
                best = { found: true, eta, latency: lat, hops: 1, contact_ids: [c.id], nodes: [srcId, dstId] };
              }
            }
          }
        });
        if (best) result = best;
      }

      return result;
    }

    function kYenRoutes(srcId, dstId, t0, bundle_bytes, k) {
      const routes = [];
      const base = (config.routingAlgorithm === 'cgr-enhanced' || config.routingAlgorithm === 'auto')
        ? cgrEnhancedSearch(srcId, dstId, t0, bundle_bytes)
        : cgrClassicSearch(srcId, dstId, t0, bundle_bytes);

      if (!base.found) return routes;
      routes.push(base);

      // Alternativas removiendo aristas del mejor
      for (let i = 1; i < k; i++) {
        const ref = routes[0];
        let added = false;

        for (let spur = 0; spur < ref.hops && !added; spur++) {
          const bannedId = ref.contact_ids[spur];
          const old = contactGraph;
          contactGraph = old.filter(c => c.id !== bannedId);

          const alt = (config.routingAlgorithm === 'cgr-enhanced' || config.routingAlgorithm === 'auto')
            ? cgrEnhancedSearch(srcId, dstId, t0, bundle_bytes)
            : cgrClassicSearch(srcId, dstId, t0, bundle_bytes);

          contactGraph = old;

          if (alt.found) {
            const isDup = routes.some(r =>
              r.hops === alt.hops &&
              r.contact_ids.length === alt.contact_ids.length &&
              r.contact_ids.every((id, j) => id === alt.contact_ids[j])
            );
            if (!isDup) { routes.push(alt); added = true; }
          }
        }
      }
      return routes;
    }

    // =============== ROUTE VISUALIZATION ===============
    function clearRoute() {
      routeEntities.forEach(e => viewer.entities.remove(e));
      routeEntities = [];
    }

    function visualizeRoute(route) {
      clearRoute();
      if (!route || !route.found) return;

      // Dibuja las aristas de la ruta (l√≠neas m√°s gruesas/bright)
      const idToContact = {};
      contactGraph.forEach(c => idToContact[c.id] = c);

      route.contact_ids.forEach(cid => {
        const c = idToContact[cid];
        const s1 = satellites.find(s => s.id === c.from);
        const s2 = satellites.find(s => s.id === c.to);
        if (!s1 || !s2) return;

        const ent = viewer.entities.add({
          polyline: {
            positions: new Cesium.CallbackProperty(() => {
              const t = simSeconds();
              const p1 = getSatellitePosition(s1.plane, s1.index, s1.meanAnomalyStart, s1.inclination, s1.raan, t);
              const p2 = getSatellitePosition(s2.plane, s2.index, s2.meanAnomalyStart, s2.inclination, s2.raan, t);
              return [p1, p2];
            }, false),
            width: 3.0,
            material: new Cesium.PolylineGlowMaterialProperty({
              glowPower: 0.25,
              color: Cesium.Color.fromCssColorString('#ffffff')
            })
          }
        });
        routeEntities.push(ent);
      });

      // Actualiza m√©tricas de ruta
      document.getElementById('routeLatency').textContent = `${route.latency.toFixed(2)} s`;
      document.getElementById('routeHops').textContent = `${route.hops}`;
    }

    function displayAlternativeRoutes(routes) {
      const div = document.getElementById('alternativeRoutes');
      div.innerHTML = '';
      routes.forEach((r, idx) => {
        const el = document.createElement('div');
        el.className = 'route-step';
        el.innerHTML = `<strong>Route ${idx+1}</strong> ‚Äî Hops: ${r.hops}, Latency: ${r.latency.toFixed(2)} s`;
        div.appendChild(el);
      });
    }

    // =============== METRICS & REPLAN ===============
    function updateMetrics() {
      const nowSec = simSeconds();
      const active = contactGraph.filter(c => nowSec >= c.t_start && nowSec < c.t_end).length;
      document.getElementById('activeContacts').textContent = active;
    }

    function replanRoute() {
      if (!sourceNode || !destNode || sourceNode.id === destNode.id) return;

      const t0 = simSeconds();
      const tStart = performance.now();

      let mode = document.getElementById('routingAlgorithm').value;
      if (mode === 'auto') {
        // Heur√≠stica simple: si hay muchas aristas activas, enhanced; si no, classic
        const actives = contactGraph.filter(c => t0 >= c.t_start && t0 < c.t_end).length;
        mode = (actives > Math.max(10, satellites.length / 2)) ? 'cgr-enhanced' : 'cgr-classic';
      }
      config.routingAlgorithm = mode;
      document.getElementById('activeAlgo').textContent = (mode === 'cgr-enhanced') ? 'CGR Enhanced' : (mode === 'cgr-classic') ? 'CGR Classic' : 'Auto';

      const bundleBytes = config.bundleSize;
      const result = (mode === 'cgr-enhanced') ? cgrEnhancedSearch(sourceNode.id, destNode.id, t0, bundleBytes)
                                               : cgrClassicSearch(sourceNode.id, destNode.id, t0, bundleBytes);

      // Si no encontr√≥, fuerza enhanced con fallback total
      const finalResult = result.found ? result : cgrEnhancedSearch(sourceNode.id, destNode.id, t0, bundleBytes);

      const tEnd = performance.now();
      document.getElementById('calcTime').textContent = `${(tEnd - tStart).toFixed(1)} ms`;
      document.getElementById('lastRecalc').textContent = `${t0.toFixed(1)} s`;

      currentRoute = finalResult.found ? finalResult : null;
      visualizeRoute(currentRoute);

      // Alternativas
      const k = config.kRoutes;
      const routes = kYenRoutes(sourceNode.id, destNode.id, t0, bundleBytes, k);
      if (routes.length === 0 && currentRoute) routes.push(currentRoute);
      displayAlternativeRoutes(routes);
    }

    // =============== BUTTONS ===============
    function changeSenderReceiver() {
      if (satellites.length < 2) return;
      // Aleatorio distinto
      const a = satellites[Math.floor(Math.random() * satellites.length)];
      let b = satellites[Math.floor(Math.random() * satellites.length)];
      if (a.id === b.id) b = satellites[(satellites.indexOf(a) + 1) % satellites.length];
      sourceNode = a; destNode = b;
      recolorSourceDest();
      replanRoute();
    }

    function toggleAnimation() {
      viewer.clock.shouldAnimate = !viewer.clock.shouldAnimate;
    }

    function resetView() {
      viewer.camera.flyHome(1.2);
    }

    // =============== LISTENERS (SLIDERS/INPUTS) ===============
    document.getElementById('satCount').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 9) / (36 - 9) * 100}%`);
      config.satCount = v;
      document.getElementById('satCountDisplay').textContent = v;
    });
    document.getElementById('satCount').addEventListener('change', () => {
      initConstellation(config.satCount, config.altitude);
      buildContactGraph();
      replanRoute();
    });

    document.getElementById('altitude').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 400) / (1200 - 400) * 100}%`);
      config.altitude = v * 1000;
      document.getElementById('altDisplay').textContent = v;
    });
    document.getElementById('altitude').addEventListener('change', () => {
      initConstellation(config.satCount, config.altitude);
      buildContactGraph();
      replanRoute();
    });

    document.getElementById('simSpeed').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 1) / (100 - 1) * 100}%`);
      config.simSpeed = v;
      document.getElementById('speedDisplay').textContent = `${v}x`;
      viewer.clock.multiplier = v;
    });

    document.getElementById('recalcFreq').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 1) / 9 * 100}%`);
      config.recalcFreq = v;
      document.getElementById('recalcDisplay').textContent = v;
    });

    document.getElementById('planningHorizon').addEventListener('change', (e) => {
      const v = parseInt(e.target.value, 10);
      config.planningHorizon = Math.max(5, Math.min(180, v)) * 60;
      buildContactGraph();
      replanRoute();
    });

    document.getElementById('bundleSize').addEventListener('change', (e) => {
      config.bundleSize = Math.max(1, parseInt(e.target.value, 10)) * 1e6;
      replanRoute();
    });

    document.getElementById('kRoutes').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 1) / 9 * 100}%`);
      config.kRoutes = v;
      document.getElementById('kDisplay').textContent = v;
      replanRoute();
    });

    document.getElementById('routingAlgorithm').addEventListener('change', (e) => {
      config.routingAlgorithm = e.target.value;
      replanRoute();
    });

    document.getElementById('safeDistance').addEventListener('change', (e) => {
      const km = Math.max(1, Math.min(50, parseInt(e.target.value, 10)));
      config.safeDistance = km * 1000;
    });

    // =============== CLOCK TICK LOOP ===============
    let lastRecalcSec = 0;
    let lastMetricsSec = 0;

    viewer.clock.onTick.addEventListener(() => {
      const t = simSeconds();
      // Sim time display
      const el = document.getElementById('simTimeDisplay');
      if (el) el.textContent = t.toFixed(1);

      // m√©tricas ~2/seg
      if (t - lastMetricsSec > 0.5) {
        updateMetrics();
        updateContactWindowsList();
        lastMetricsSec = t;
      }

      // colisiones ~1/seg
      detectCollisions();

      // replan peri√≥dico
      if (t - lastRecalcSec >= config.recalcFreq) {
        buildContactGraph();
        replanRoute();
        lastRecalcSec = t;
      }
    });

    // =============== INIT ===============
    function boot() {
      updateDisplayBadges();
      initConstellation(config.satCount, config.altitude);
      buildContactGraph();
      replanRoute();
      viewer.camera.flyHome(0);
    }
    boot();

    // Expose for buttons
    window.changeSenderReceiver = changeSenderReceiver;
    window.toggleAnimation = toggleAnimation;
    window.resetView = resetView;
    window.switchTab = switchTab;
    window.toggleBottomPanel = toggleBottomPanel;

  </script>
</body>
</html>
