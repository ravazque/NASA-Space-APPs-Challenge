<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CGR Enhanced v3.4 - Dynamic LEO Routing</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.95/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow: hidden; background: #0a0e27; }
    #cesiumContainer { width: 100vw; height: 100vh; }

    .panel {
      position: absolute;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);
      color: #e2e8f0;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 0 1px rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }
    #leftPanel { top: 20px; left: 20px; width: 420px; max-height: calc(100vh - 40px); overflow-y: auto; }
    #rightPanel { top: 20px; right: 20px; width: 480px; max-height: calc(100vh - 40px); overflow-y: auto; }

    /* Bottom panel: evitar superposiciones */
    #bottomPanel {
      bottom: 20px; left: 50%; transform: translateX(-50%);
      width: 700px; max-height: 350px; transition: max-height 0.3s ease; overflow: hidden;
    }
    #bottomPanel.collapsed { max-height: 60px; overflow: hidden; }
    .toggle-header { cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center; }
    .toggle-icon { transition: transform 0.3s ease; }
    .toggle-icon.collapsed { transform: rotate(-90deg); }

    .header { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(99, 102, 241, 0.3); }
    h2 { font-size: 22px; font-weight: 700; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 8px; letter-spacing: -0.5px; }
    .subtitle { font-size: 12px; color: #94a3b8; font-weight: 500; text-transform: uppercase; letter-spacing: 0.8px; }
    h3 { margin: 25px 0 15px 0; font-size: 15px; color: #cbd5e1; text-transform: uppercase; letter-spacing: 1px; font-weight: 600; border-left: 3px solid #6366f1; padding-left: 10px; }

    .section { background: rgba(30, 41, 59, 0.4); padding: 16px; border-radius: 10px; margin-bottom: 16px; border: 1px solid rgba(100, 116, 139, 0.15); transition: all 0.3s ease; }
    .section:hover { background: rgba(30, 41, 59, 0.6); border-color: rgba(99, 102, 241, 0.3); }
    label { display: block; margin-bottom: 10px; font-size: 13px; color: #cbd5e1; font-weight: 500; }

    input[type="range"] { width: 100%; height: 8px; border-radius: 4px; background: linear-gradient(to right, #6366f1 0%, #6366f1 var(--value), rgba(148,163,184,0.2) var(--value), rgba(148,163,184,0.2) 100%); outline: none; margin: 10px 0; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); cursor: pointer; box-shadow: 0 4px 12px rgba(99, 102, 241, 0.5); transition: transform 0.2s; }
    input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

    input[type="number"], select {
      width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(100, 116, 139, 0.3); border-radius: 8px; color: #e2e8f0; font-size: 14px; font-family: 'SF Mono', 'Menlo', monospace; transition: all 0.3s;
    }
    input[type="number"]:focus, select:focus { outline: none; border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }

    button {
      width: 100%; padding: 14px; margin: 8px 0; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s; box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4); position: relative; overflow: hidden;
    }
    button::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%); transform: translateX(-100%); transition: transform 0.3s; }
    button:hover::before { transform: translateX(0); }
    button:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.6); }
    button:active { transform: translateY(0); }
    button.secondary { background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.8) 100%); box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3); }

    .value-badge { display: inline-block; background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); padding: 4px 12px; border-radius: 8px; margin-left: 10px; font-weight: 700; font-size: 13px; font-family: 'SF Mono', 'Menlo', monospace; box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3); }
    .metric-card { background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(51, 65, 85, 0.7) 100%); padding: 16px 18px; border-radius: 12px; margin: 12px 0; border-left: 4px solid #6366f1; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.3s; }
    .metric-card:hover { transform: translateX(5px); border-left-color: #a855f7; }
    .metric-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; }
    .metric-label { color: #94a3b8; font-size: 13px; font-weight: 500; }
    .metric-value { color: #e2e8f0; font-weight: 700; font-size: 17px; font-family: 'SF Mono', 'Menlo', monospace; }
    .metric-value.highlight { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 20px; }
    .contact-window { background: rgba(30, 41, 59, 0.6); padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 3px solid #10b981; font-size: 12px; transition: all 0.3s; }
    .contact-window:hover { background: rgba(30, 41, 59, 0.8); transform: translateX(3px); }
    .contact-window.active { border-left-color: #22c55e; background: rgba(34, 197, 94, 0.15); box-shadow: 0 0 20px rgba(34, 197, 94, 0.3); }
    .route-step { background: rgba(99, 102, 241, 0.15); padding: 12px; border-radius: 8px; margin: 8px 0; border-left: 3px solid #6366f1; font-size: 13px; }

    .status-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 10px; animation: pulse 2s ease-in-out infinite; box-shadow: 0 0 10px currentColor; }
    .status-indicator.active { background: #22c55e; color: #22c55e; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.7; transform: scale(1.1); } }

    .algo-info { background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); padding: 14px; border-radius: 10px; margin: 12px 0; font-size: 12px; line-height: 1.7; }

    .legend-box { background: rgba(30, 41, 59, 0.5); padding: 14px; border-radius: 8px; margin: 15px 0; border: 1px solid rgba(100, 116, 139, 0.2); }
    .legend-item { display: flex; align-items: center; margin: 8px 0; font-size: 12px; }
    .legend-color { width: 16px; height: 16px; border-radius: 50%; margin-right: 10px; border: 2px solid white; }
    .legend-color.source { background: #22c55e; }
    .legend-color.destination { background: #ef4444; }
    .legend-color.normal { background: #06b6d4; }

    .collision-warning { background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; padding: 12px; border-radius: 8px; margin: 8px 0; font-size: 12px; animation: warning-pulse 2s ease-in-out infinite; }
    @keyframes warning-pulse { 0%, 100% { background: rgba(239, 68, 68, 0.2); } 50% { background: rgba(239, 68, 68, 0.4); } }
    .collision-safe { background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; padding: 12px; border-radius: 8px; margin: 8px 0; font-size: 12px; }

    .tab-container { display: flex; gap: 8px; margin-bottom: 16px; }
    .tab { flex: 1; padding: 10px; background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(100, 116, 139, 0.2); border-radius: 8px; cursor: pointer; text-align: center; font-size: 12px; font-weight: 600; transition: all 0.3s; }
    .tab:hover { background: rgba(30, 41, 59, 0.8); }
    .tab.active { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); border-color: #6366f1; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
    #contactsTab, #collisionsTab { max-height: 240px; overflow-y: auto; padding-right: 6px; }

    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: rgba(30, 41, 59, 0.5); border-radius: 5px; }
    ::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%); border-radius: 5px; }
    ::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #a855f7 0%, #6366f1 100%); }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <!-- Left Panel -->
  <div id="leftPanel" class="panel">
    <div class="header">
      <h2>Advanced Configuration</h2>
      <div class="subtitle">CGR Enhanced v3.4 <span class="badge-new">OPTIMIZED</span></div>
    </div>

    <div class="section">
      <label>Number of Satellites: <span class="value-badge" id="satCountDisplay">27</span></label>
      <input type="range" id="satCount" min="9" max="36" value="27" step="9" style="--value: 67%">
    </div>

    <div class="section">
      <label>Orbital Altitude (km): <span class="value-badge" id="altDisplay">600</span></label>
      <input type="range" id="altitude" min="400" max="1200" value="600" step="50" style="--value: 25%">
    </div>

    <div class="section">
      <label>Simulation Speed: <span class="value-badge" id="speedDisplay">20x</span></label>
      <input type="range" id="simSpeed" min="1" max="100" value="20" step="1" style="--value: 20%">
    </div>

    <h3>CGR Algorithm <span class="badge-new">AUTO-ADAPTIVE</span></h3>

    <div class="section">
      <label>Routing Mode:</label>
      <select id="routingAlgorithm">
        <option value="cgr-classic">CGR Classic</option>
        <option value="cgr-enhanced" selected>CGR Enhanced (Optimized)</option>
        <option value="auto">Auto (Best Performance)</option>
      </select>
    </div>

    <div class="section">
      <label>Recalculation Frequency (s): <span class="value-badge" id="recalcDisplay">3</span></label>
      <input type="range" id="recalcFreq" min="1" max="10" value="3" step="1" style="--value: 22%">
    </div>

    <div class="section">
      <label>Planning Horizon (min):</label>
      <input type="number" id="planningHorizon" value="30" min="5" max="180" step="5">
    </div>

    <div class="section">
      <label>Bundle Size (MB):</label>
      <input type="number" id="bundleSize" value="10" min="1" max="500" step="1">
    </div>

    <div class="algo-info">
      <strong>Conceptos clave:</strong><br>
      <b>Bundle Size</b>: tama√±o estimado del ‚Äúpaquete‚Äù a enrutar; afecta la elegibilidad de ventanas (setup/tiempos).<br>
      <b>Planning Horizon</b>: ventana de tiempo hacia delante (en minutos) en la que se planifican rutas y contactos.<br>
      <b>Recalculation Frequency</b>: periodo (s) para recalcular rutas/contactos y adaptarse a cambios.
    </div>

    <h3>Alternative Routes</h3>
    <div class="section">
      <label>K Routes (Yen's Algorithm): <span class="value-badge" id="kDisplay">3</span></label>
      <input type="range" id="kRoutes" min="1" max="10" value="3" step="1" style="--value: 22%">
      <div class="algo-info" style="margin-top:10px">
        <strong>What are K Routes?</strong><br>
        Genera las <em>k</em> mejores rutas como alternativas a la √≥ptima.<br>
        <u>Impacto</u>: aumentar <em>k</em> mejora robustez/selecci√≥n, pero incrementa el coste de c√≥mputo.
      </div>
    </div>

    <div class="legend-box">
      <div class="legend-item"><div class="legend-color source"></div><span><strong>Green:</strong> Source Node</span></div>
      <div class="legend-item"><div class="legend-color destination"></div><span><strong>Red:</strong> Destination Node</span></div>
      <div class="legend-item"><div class="legend-color normal"></div><span><strong>Cyan:</strong> Regular Satellite</span></div>
    </div>

    <button onclick="changeSenderReceiver()">üîÑ Change Source & Destination</button>
    <button onclick="toggleAnimation()" class="secondary">‚èØÔ∏è Play/Pause</button>
    <button onclick="resetView()" class="secondary">üè† Reset View</button>
  </div>

  <!-- Right Panel -->
  <div id="rightPanel" class="panel">
    <div class="header">
      <h2>Real-time Metrics</h2>
      <div class="subtitle">System Performance</div>
    </div>

    <div class="metric-card">
      <div class="status-indicator active"></div>
      <strong>Active Algorithm:</strong> <span id="activeAlgo">CGR Enhanced</span>
    </div>

    <div class="metric-card">
      <div class="metric-row"><span class="metric-label">Active Links:</span><span class="metric-value highlight" id="activeContacts">0</span></div>
      <div class="metric-row"><span class="metric-label">Simulation Time:</span><span class="metric-value" id="simTimeMetric">0.0 s</span></div>
      <div class="metric-row"><span class="metric-label">Calculation Time:</span><span class="metric-value" id="calcTime">-</span></div>
    </div>

    <h3>Collision Prevention</h3>
    <div class="section">
      <label>Minimum Safe Distance (km):</label>
      <input type="number" id="safeDistance" value="750" min="1" max="5000" step="50">
    </div>
    <div id="collisionStatus"></div>

    <h3>Active Route</h3>
    <div class="metric-card">
      <div class="metric-row"><span class="metric-label">E2E Latency:</span><span class="metric-value highlight" id="routeLatency">-</span></div>
      <div class="metric-row"><span class="metric-label">Total Hops:</span><span class="metric-value" id="routeHops">-</span></div>
    </div>

    <h3>Alternative K-Yen Routes</h3>
    <div id="alternativeRoutes" style="max-height: 180px; overflow-y: auto;"></div>
  </div>

  <!-- Bottom Panel -->
  <div id="bottomPanel" class="panel collapsed">
    <div class="header toggle-header" onclick="toggleBottomPanel()">
      <div>
        <h2>System Information</h2>
        <div class="subtitle">Contact Windows & Collision Alerts</div>
      </div>
      <span class="toggle-icon collapsed">‚ñº</span>
    </div>
    <div class="collapsible-content" id="contactWindowsContent">
      <div class="tab-container">
        <div class="tab active" onclick="switchTab('contacts')">Contact Windows</div>
        <div class="tab" onclick="switchTab('collisions')">Collision Alerts</div>
      </div>

      <div id="contactsTab" class="tab-content active"><div id="contactWindows"></div></div>
      <div id="collisionsTab" class="tab-content"><div id="collisionsList"></div></div>
    </div>
  </div>

  <script>
    // =============== CESIUM INITIALIZATION ===============
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5N2UyMjcwOS00MDY1LTQxYjEtYjZjMy00YTU0ZTg1YmJhMzEiLCJpZCI6ODAzMDYsImlhdCI6MTY0Mjc0ODI2MX0.dkwAL1CcljUV7NA7fDbhXXnmyZQU_c-G5zRx8PtEcxE';

    const viewer = new Cesium.Viewer('cesiumContainer', {
      imageryProvider: new Cesium.TileMapServiceImageryProvider({
        url: Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII')
      }),
      baseLayerPicker: false,
      geocoder: false,
      homeButton: false,
      sceneModePicker: false,
      timeline: true,
      animation: true,
      navigationHelpButton: false,
      fullscreenButton: false
    });

    viewer.scene.globe.enableLighting = true;
    viewer.scene.globe.atmosphereLightIntensity = 3.0;
    viewer.scene.globe.showGroundAtmosphere = true;

    // =============== CONSTANTS ===============
    const EARTH_RADIUS = 6_371_000; // m
    const C = 299_792_458; // m/s

    // =============== STATE ===============
    let satellites = [];
    let contactGraph = [];
    let currentRoute = null;
    let linkEntities = [];
    let routeEntities = [];
    let collisionWarnings = [];
    let activeTab = 'contacts';

    let sourceNode = null;
    let destNode = null;

    // =============== CONFIG ===============
    let config = {
      satCount: 27,
      altitude: 600_000,         // m
      simSpeed: 20,
      planningHorizon: 30 * 60,  // s
      bundleSize: 10 * 1e6,      // bytes (empieza en 10 MB)
      routingAlgorithm: 'cgr-enhanced',
      kRoutes: 3,
      safeDistance: 750_000,     // m (750 km)

      // Clasificaci√≥n √≥ptico en LEO con umbrales m√°s realistas
      leoMinAlt: 160_000,        // 160 km
      leoMaxAlt: 2_000_000,      // 2000 km
      opticalMaxDistInter: 2_500_000, // 2500 km entre planos
      opticalMaxDistIntra: 3_000_000, // 3000 km intra-plano

      recalcFreq: 3              // s
    };

    // =============== CLOCK ===============
    const startJD = Cesium.JulianDate.now();
    const stopJD  = Cesium.JulianDate.addDays(startJD, 1, new Cesium.JulianDate());
    viewer.clock.startTime   = startJD.clone();
    viewer.clock.stopTime    = stopJD.clone();
    viewer.clock.currentTime = startJD.clone();
    viewer.clock.clockRange  = Cesium.ClockRange.LOOP_STOP;
    viewer.clock.multiplier  = config.simSpeed;
    viewer.clock.shouldAnimate = true;

    function simSeconds() {
      return Cesium.JulianDate.secondsDifference(viewer.clock.currentTime, viewer.clock.startTime);
    }

    // =============== UI HELPERS ===============
    function toggleBottomPanel() {
      const panel = document.getElementById('bottomPanel');
      const content = document.getElementById('contactWindowsContent');
      const icon = document.querySelector('#bottomPanel .toggle-icon');
      if (panel.classList.contains('collapsed')) {
        panel.classList.remove('collapsed');
        content.style.maxHeight = '280px';
        icon.classList.remove('collapsed');
      } else {
        panel.classList.add('collapsed');
        content.style.maxHeight = '0';
        icon.classList.add('collapsed');
      }
    }

    function switchTab(tabName) {
      activeTab = tabName;
      document.querySelectorAll('#bottomPanel .tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('#bottomPanel .tab-content').forEach(content => content.classList.remove('active'));
      if (tabName === 'contacts') {
        document.querySelector('#bottomPanel .tab:nth-child(1)').classList.add('active');
        document.getElementById('contactsTab').classList.add('active');
      } else {
        document.querySelector('#bottomPanel .tab:nth-child(2)').classList.add('active');
        document.getElementById('collisionsTab').classList.add('active');
      }
    }

    function updateDisplayBadges() {
      document.getElementById('satCountDisplay').textContent = config.satCount;
      document.getElementById('altDisplay').textContent = Math.round(config.altitude/1000);
      document.getElementById('speedDisplay').textContent = `${config.simSpeed}x`;
      document.getElementById('recalcDisplay').textContent = config.recalcFreq;
      document.getElementById('kDisplay').textContent = config.kRoutes;
    }

    // =============== ORBIT & POSITIONS ===============
    const ORBITAL_PERIOD_SIM = 6000; // s (animaci√≥n)

    function getSatellitePosition(plane, satIndex, meanAnomalyStart, inclination, raan, tSec) {
      const meanMotion = (2 * Math.PI) / ORBITAL_PERIOD_SIM;
      const meanAnomalyDeg = meanAnomalyStart + (meanMotion * tSec * 180 / Math.PI);

      const a = EARTH_RADIUS + config.altitude;
      const incRad = Cesium.Math.toRadians(inclination);
      const raanRad = Cesium.Math.toRadians(raan);
      const maRad = Cesium.Math.toRadians(meanAnomalyDeg);

      const x = a * (Math.cos(raanRad) * Math.cos(maRad) - Math.sin(raanRad) * Math.sin(maRad) * Math.cos(incRad));
      const y = a * (Math.sin(raanRad) * Math.cos(maRad) + Math.cos(raanRad) * Math.sin(maRad) * Math.cos(incRad));
      const z = a * Math.sin(maRad) * Math.sin(incRad);

      return new Cesium.Cartesian3(x, y, z);
    }

    function addSatelliteEntity(sat) {
      const color =
        (sourceNode && sat.id === sourceNode.id) ? Cesium.Color.LIME :
        (destNode && sat.id === destNode.id) ? Cesium.Color.RED :
        Cesium.Color.CYAN;

      sat.entity = viewer.entities.add({
        name: `SAT-${sat.id}`,
        position: new Cesium.CallbackProperty(() => {
          const t = simSeconds();
          return getSatellitePosition(sat.plane, sat.index, sat.meanAnomalyStart, sat.inclination, sat.raan, t);
        }, false),
        point: { pixelSize: 8, color: color, outlineWidth: 2, outlineColor: Cesium.Color.WHITE }
      });
    }

    function clearSatellites() {
      satellites.forEach(s => { if (s.entity) viewer.entities.remove(s.entity); });
      satellites = [];
    }

    function initConstellation(satCount, altitude) {
      clearSatellites();

      const planes = Math.max(1, Math.round(satCount / 9)); // ej. 27 => 3 planos
      const satsPerPlane = Math.round(satCount / planes);
      const baseInclination = 53; // grados
      const raanStep = 360 / planes;

      let idCounter = 1;

      for (let p = 0; p < planes; p++) {
        const raan = (p * raanStep) % 360;
        for (let s = 0; s < satsPerPlane; s++) {
          const meanAnomalyStart = (s * 360 / satsPerPlane) % 360;
          const sat = {
            id: idCounter++,
            plane: p,
            index: s,
            meanAnomalyStart,
            inclination: baseInclination + (p % 2 === 0 ? 0 : 5),
            raan,
            entity: null
          };
          satellites.push(sat);
        }
      }

      satellites = satellites.slice(0, satCount);
      satellites.forEach(addSatelliteEntity);

      if (!sourceNode) sourceNode = satellites[0];
      if (!destNode) destNode = satellites[satellites.length - 1];
      recolorSourceDest();
    }

    function recolorSourceDest() {
      satellites.forEach(sat => {
        if (!sat.entity) return;
        const mat =
          (sourceNode && sat.id === sourceNode.id) ? Cesium.Color.LIME :
          (destNode && sat.id === destNode.id) ? Cesium.Color.RED :
          Cesium.Color.CYAN;
        sat.entity.point.color = mat;
      });
    }

    // =============== CONTACT WINDOWS & GRAPH ===============
    function calculateLinkQuality(distance, sat1, sat2) {
      const maxDist = 5_500_000; // 5500 km
      const distanceFactor = Math.max(0, 1 - (distance / maxDist)); // 0..1
      const planeDiversity = Math.abs(sat1.plane - sat2.plane) / 2;
      const altitudeFactor = (config.altitude >= config.leoMinAlt && config.altitude <= config.leoMaxAlt) ? 1.0 : 0.7;
      const q = (distanceFactor * 0.6 + planeDiversity * 0.2 + altitudeFactor * 0.2);
      return Math.max(0.05, Math.min(1, q));
    }

    function classifyLinkType(s1, s2, distance) {
      const inLEO = (config.altitude >= config.leoMinAlt && config.altitude <= config.leoMaxAlt);
      if (!inLEO) return 'rf';
      const samePlane = (s1.plane === s2.plane);
      const okIntra = samePlane && (distance <= config.opticalMaxDistIntra);
      const okInter = !samePlane && (distance <= config.opticalMaxDistInter);
      return (okIntra || okInter) ? 'optical' : 'rf';
    }

    function findOptimalContactWindows(s1, s2, startTime, endTime) {
      const windows = [];
      const timeStep = 30;                // s
      const maxDistance = 5_500_000;      // m
      let inContact = false;
      let windowStart = null;
      let bestDistance = Infinity;

      for (let t = startTime; t <= endTime; t += timeStep) {
        const p1 = getSatellitePosition(s1.plane, s1.index, s1.meanAnomalyStart, s1.inclination, s1.raan, t);
        const p2 = getSatellitePosition(s2.plane, s2.index, s2.meanAnomalyStart, s2.inclination, s2.raan, t);
        const d  = Cesium.Cartesian3.distance(p1, p2);

        if (d <= maxDistance && !inContact) {
          inContact = true; windowStart = t; bestDistance = d;
        } else if (inContact) {
          if (d < bestDistance) bestDistance = d;
          if (d > maxDistance || t === endTime) {
            inContact = false;
            if (windowStart !== null && (t - windowStart) > 30) {
              windows.push({
                start: windowStart,
                end: t,
                distance: bestDistance
              });
            }
          }
        }
      }
      return windows;
    }

    function buildContactGraph() {
      const t0 = simSeconds();
      const t1 = t0 + config.planningHorizon;
      contactGraph = [];

      // limpia enlaces visuales previos
      linkEntities.forEach(e => viewer.entities.remove(e));
      linkEntities = [];

      for (let i = 0; i < satellites.length; i++) {
        for (let j = i + 1; j < satellites.length; j++) {
          const s1 = satellites[i], s2 = satellites[j];
          const wins = findOptimalContactWindows(s1, s2, t0, t1);

          wins.forEach((w) => {
            const quality = calculateLinkQuality(w.distance, s1, s2);
            const type = classifyLinkType(s1, s2, w.distance); // LEO + distancia ‚Üí √≥ptico (azul) o RF (naranja)
            const owlt = w.distance / C;
            const setup_s = 0.2 + (1 - quality) * 0.6;

            const idF = `C_${s1.id}_${s2.id}_${Math.round(w.start)}`;
            const idB = `C_${s2.id}_${s1.id}_${Math.round(w.start)}`;

            const recF = { id: idF, from: s1.id, to: s2.id, t_start: w.start, t_end: w.end, owlt, setup_s, type, quality };
            const recB = { id: idB, from: s2.id, to: s1.id, t_start: w.start, t_end: w.end, owlt, setup_s, type, quality };

            contactGraph.push(recF, recB);

            // Dibuja enlace vivo (color por tipo)
            const ent = viewer.entities.add({
              polyline: {
                positions: new Cesium.CallbackProperty(() => {
                  const t = simSeconds();
                  const p1 = getSatellitePosition(s1.plane, s1.index, s1.meanAnomalyStart, s1.inclination, s1.raan, t);
                  const p2 = getSatellitePosition(s2.plane, s2.index, s2.meanAnomalyStart, s2.inclination, s2.raan, t);
                  return [p1, p2];
                }, false),
                width: 1.4,
                material: (type === 'optical'
                  ? Cesium.Color.fromCssColorString('#3b82f6')  // azul
                  : Cesium.Color.fromCssColorString('#f59e0b')  // naranja
                ).withAlpha(0.5)
              }
            });
            linkEntities.push(ent);
          });
        }
      }

      updateContactWindowsList();
    }

    function updateContactWindowsList() {
      const list = document.getElementById('contactWindows');
      list.innerHTML = '';
      const nowSec = simSeconds();
      const soon = contactGraph
        .filter(c => c.t_end >= nowSec)
        .sort((a, b) => a.t_start - b.t_start)
        .slice(0, 12);

      soon.forEach(c => {
        const div = document.createElement('div');
        div.className = 'contact-window';
        const active = nowSec >= c.t_start && nowSec < c.t_end;
        if (active) div.classList.add('active');
        div.innerHTML = `
          <div class="contact-info"><span class="contact-label"><strong>${c.from} ‚Üí ${c.to}</strong></span><span class="contact-value">${c.type === 'optical' ? 'OPTICAL (BLUE)' : 'RF (ORANGE)'}</span></div>
          <div class="contact-info"><span class="contact-label">Start in:</span><span class="contact-value">${Math.max(0,(c.t_start - nowSec)).toFixed(0)} s</span></div>
          <div class="contact-info"><span class="contact-label">End in:</span><span class="contact-value">${Math.max(0,(c.t_end - nowSec)).toFixed(0)} s</span></div>
          <div class="contact-info"><span class="contact-label">OWLT:</span><span class="contact-value">${(c.owlt*1000).toFixed(1)} ms</span></div>
          <div class="contact-info"><span class="contact-label">Q:</span><span class="contact-value">${(c.quality).toFixed(2)}</span></div>
        `;
        list.appendChild(div);
      });
    }

    // =============== COLLISION PREVENTION (probabilidad, vel, TCA, DCA) ===============
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    function detectCollisions() {
      collisionWarnings = [];
      const safeKm = config.safeDistance / 1000;
      const t = simSeconds();
      const dt = 1.0; // s, paso para obtener velocidad aproximada

      for (let i = 0; i < satellites.length; i++) {
        for (let j = i + 1; j < satellites.length; j++) {
          const a = satellites[i], b = satellites[j];

          // posiciones ahora y en t+dt
          const p1  = getSatellitePosition(a.plane, a.index, a.meanAnomalyStart, a.inclination, a.raan, t);
          const p2  = getSatellitePosition(b.plane, b.index, b.meanAnomalyStart, b.inclination, b.raan, t);
          const p1n = getSatellitePosition(a.plane, a.index, a.meanAnomalyStart, a.inclination, a.raan, t + dt);
          const p2n = getSatellitePosition(b.plane, b.index, b.meanAnomalyStart, b.inclination, b.raan, t + dt);

          const r = Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3());   // m
          const v1 = Cesium.Cartesian3.subtract(p1n, p1, new Cesium.Cartesian3()); // m/s aprox (dt=1)
          const v2 = Cesium.Cartesian3.subtract(p2n, p2, new Cesium.Cartesian3());
          const v = Cesium.Cartesian3.subtract(v2, v1, new Cesium.Cartesian3());   // relativa

          const rKm = Cesium.Cartesian3.magnitude(r) / 1000;
          const vRel = Cesium.Cartesian3.magnitude(v); // m/s
          const closing = Cesium.Cartesian3.dot(r, v) < 0;

          // TCA (aprox. lineal): t* = - (r¬∑v)/|v|^2
          const v2norm = vRel * vRel;
          let tca = (v2norm > 0) ? - Cesium.Cartesian3.dot(r, v) / v2norm : 0;
          tca = Math.max(0, Math.min(900, tca)); // limitamos a 15 min

          // Distancia en TCA
          const rAtTca = new Cesium.Cartesian3(
            r.x + v.x * tca,
            r.y + v.y * tca,
            r.z + v.z * tca
          );
          const dcaKm = Cesium.Cartesian3.magnitude(rAtTca) / 1000;

          // Heur√≠stica de probabilidad (0..1) m√°s estable:
          // - d_rel>0 si DCA < safeKm; escala 0..1
          // - t_factor mayor cuando TCA es corto
          // - closing factor si se est√°n acercando
          const d_rel = clamp01((safeKm - dcaKm) / safeKm);
          const t_factor = 1 / (1 + tca / 300);     // 0..1, privilegia TCA corto
          const closing_factor = closing ? 1.0 : 0.6;
          let prob = clamp01(0.15 + 0.7 * d_rel) * t_factor * closing_factor;

          if (dcaKm < safeKm || rKm < safeKm * 1.1) {
            const percent = Math.max(0.1, prob * 100); // evita 0.0% visual
            collisionWarnings.push({
              sat1: `SAT-${a.id}`,
              sat2: `SAT-${b.id}`,
              distanceNowKm: rKm.toFixed(0),
              vRelKms: (vRel / 1000).toFixed(2),
              tcaSec: tca.toFixed(0),
              dcaKm: dcaKm.toFixed(1),
              probability: percent.toFixed(1) + '%',
              riskLevel: (dcaKm < safeKm/2) ? 'CRITICAL' : (dcaKm < safeKm ? 'HIGH' : 'MEDIUM')
            });
          }
        }
      }
      updateCollisionDisplay();
    }

    function updateCollisionDisplay() {
      const statusDiv = document.getElementById('collisionStatus');
      const listDiv = document.getElementById('collisionsList');
      if (collisionWarnings.length === 0) {
        statusDiv.innerHTML = `<div class="collision-safe"><strong>‚úì Status: SAFE</strong><br>No collision risks detected with current threshold</div>`;
        listDiv.innerHTML = '<p style="text-align:center; color:#94a3b8;">No active collision alerts</p>';
      } else {
        const crit = collisionWarnings.filter(w => w.riskLevel === 'CRITICAL').length;
        statusDiv.innerHTML = `<div class="collision-warning"><strong>‚ö†Ô∏è COLLISION WARNING</strong><br>${collisionWarnings.length} potential risk(s); Critical: ${crit}</div>`;
        listDiv.innerHTML = '';
        collisionWarnings
          .sort((a,b)=> (a.riskLevel===b.riskLevel)?(a.dcaKm-b.dcaKm):(a.riskLevel==='CRITICAL'?-1:1))
          .forEach(w => {
            const div = document.createElement('div');
            div.className = 'contact-window';
            div.style.borderLeftColor = (w.riskLevel === 'CRITICAL') ? '#ef4444' : (w.riskLevel === 'HIGH' ? '#f59e0b' : '#fbbf24');
            div.innerHTML = `
              <div class="contact-info"><span class="contact-label"><strong>${w.sat1} - ${w.sat2}</strong></span><span class="contact-value" style="color:${w.riskLevel==='CRITICAL'?'#ef4444':(w.riskLevel==='HIGH'?'#f59e0b':'#fbbf24')}">${w.riskLevel}</span></div>
              <div class="contact-info"><span class="contact-label">Probability:</span><span class="contact-value">${w.probability}</span></div>
              <div class="contact-info"><span class="contact-label">Rel. speed:</span><span class="contact-value">${w.vRelKms} km/s</span></div>
              <div class="contact-info"><span class="contact-label">TCA:</span><span class="contact-value">${w.tcaSec} s</span></div>
              <div class="contact-info"><span class="contact-label">DCA:</span><span class="contact-value">${w.dcaKm} km</span></div>
              <div class="contact-info"><span class="contact-label">Now:</span><span class="contact-value">${w.distanceNowKm} km</span></div>
            `;
            listDiv.appendChild(div);
          });
      }
    }

    // =============== CGR CLASSIC & ENHANCED ===============
    function cgrClassicSearch(srcId, dstId, t0, bundle_bytes) {
      const distances = {};
      const arrivalTimes = {};
      const previous = {};
      const unvisited = new Set();
      const contacts = contactGraph;

      for (let i = 0; i < contacts.length; i++) {
        distances[i] = Infinity;
        arrivalTimes[i] = t0;
        previous[i] = null;
        unvisited.add(i);
      }

      // inicial desde src
      contacts.forEach((c, idx) => {
        if (c.from === srcId && c.t_start <= t0 && c.t_end > t0) {
          const eta = t0 + c.owlt + c.setup_s;
          if (eta <= c.t_end) {
            distances[idx] = eta - t0;
            arrivalTimes[idx] = eta;
          }
        }
      });

      let best_end = null;
      let best_eta = Infinity;

      while (unvisited.size > 0) {
        let current_idx = null;
        let min_dist = Infinity;
        unvisited.forEach(idx => {
          if (distances[idx] < min_dist) { min_dist = distances[idx]; current_idx = idx; }
        });
        if (current_idx === null || min_dist === Infinity) break;
        unvisited.delete(current_idx);

        const current = contacts[current_idx];
        if (current.to === dstId) { best_end = current_idx; best_eta = arrivalTimes[current_idx]; break; }

        contacts.forEach((n, nj) => {
          if (!unvisited.has(nj)) return;
          if (n.from !== current.to) return;
          if (n.t_start > arrivalTimes[current_idx]) return;
          if (n.t_end <= arrivalTimes[current_idx]) return;
          const eta_n = arrivalTimes[current_idx] + n.owlt + n.setup_s;
          if (eta_n > n.t_end) return;
          const new_dist = eta_n - t0;
          if (new_dist < distances[nj]) {
            distances[nj] = new_dist;
            arrivalTimes[nj] = eta_n;
            previous[nj] = current_idx;
          }
        });
      }

      if (best_end === null) return { found: false };

      const path = [];
      const nodes = [dstId];
      let cur = best_end;
      while (cur !== null) {
        path.unshift(contacts[cur].id);
        if (previous[cur] !== null) nodes.unshift(contacts[cur].from);
        cur = previous[cur];
      }
      return { found: true, eta: best_eta, latency: best_eta - t0, hops: path.length, contact_ids: path, nodes };
    }

    function cgrEnhancedInternal(srcId, dstId, t0, bundle_bytes) {
      const contacts = contactGraph;
      const distances = {};
      const arrivalTimes = {};
      const previous = {};
      const nodeQuality = {};
      const unvisited = new Set();

      for (let i = 0; i < contacts.length; i++) {
        distances[i] = Infinity;
        arrivalTimes[i] = t0;
        previous[i] = null;
        nodeQuality[i] = contacts[i].quality || 1.0;
        unvisited.add(i);
      }

      // seed con calidad
      contacts.forEach((c, idx) => {
        if (c.from !== srcId) return;
        if (c.t_start > t0 || c.t_end <= t0) return;
        const eta = t0 + c.owlt + c.setup_s;
        if (eta > c.t_end) return;
        const weighted = (eta - t0) * (2.0 - (c.quality || 1));
        distances[idx] = weighted;
        arrivalTimes[idx] = eta;
      });

      let best_end = null;
      let best_eta = Infinity;
      let iterations = 0;
      const maxIterations = contacts.length * 2;

      while (unvisited.size > 0 && iterations < maxIterations) {
        iterations++;
        let current_idx = null;
        let min_eff = Infinity;

        unvisited.forEach(idx => {
          const qBoost = nodeQuality[idx] * 0.9;
          const eff = distances[idx] * qBoost;
          if (eff < min_eff) { min_eff = eff; current_idx = idx; }
        });

        if (current_idx === null || distances[current_idx] === Infinity) break;
        unvisited.delete(current_idx);

        const current = contacts[current_idx];
        if (current.to === dstId) { best_end = current_idx; best_eta = arrivalTimes[current_idx]; break; }

        contacts.forEach((n, nj) => {
          if (!unvisited.has(nj)) return;
          if (n.from !== current.to) return;
          if (n.t_start > arrivalTimes[current_idx]) return;
          if (n.t_end <= arrivalTimes[current_idx]) return;

          let effective_setup = n.setup_s;
          const qDiff = Math.abs((current.quality || 1) - (n.quality || 1));
          effective_setup += qDiff * 0.2;
          // ligera preferencia por √≥ptico en LEO
          if (n.type === 'optical') effective_setup *= 0.85;

          const eta_n = arrivalTimes[current_idx] + n.owlt + effective_setup;
          if (eta_n > n.t_end) return;

          const new_dist = (eta_n - t0) * (2.0 - (n.quality || 1));
          if (new_dist < distances[nj]) {
            distances[nj] = new_dist;
            arrivalTimes[nj] = eta_n;
            previous[nj] = current_idx;
            nodeQuality[nj] = (nodeQuality[current_idx] + (n.quality || 1)) / 2;
          }
        });
      }

      if (best_end === null) return { found: false };

      const path = [];
      const nodes = [dstId];
      let cur = best_end;
      while (cur !== null) {
        path.unshift(contacts[cur].id);
        if (previous[cur] !== null) nodes.unshift(contacts[cur].from);
        cur = previous[cur];
      }
      return { found: true, eta: best_eta, latency: best_eta - t0, hops: path.length, contact_ids: path, nodes };
    }

    function cgrEnhancedSearch(srcId, dstId, t0, bundle_bytes) {
      let result = cgrEnhancedInternal(srcId, dstId, t0, bundle_bytes);

      if (!result.found) {
        const oldH = config.planningHorizon;
        config.planningHorizon = Math.max(oldH, 60 * 60);
        buildContactGraph();
        result = cgrEnhancedInternal(srcId, dstId, t0, bundle_bytes);
        config.planningHorizon = oldH;
        buildContactGraph();
      }

      if (!result.found) result = cgrClassicSearch(srcId, dstId, t0, bundle_bytes);

      // √∫ltimo recurso: enlace directo si hay ventana v√°lida
      if (!result.found) {
        const t1 = t0 + config.planningHorizon;
        let best = null;
        contactGraph.forEach(c => {
          if (c.from === srcId && c.to === dstId && c.t_end > t0 && c.t_start <= t1) {
            const start = Math.max(t0, c.t_start);
            const eta = start + c.owlt + c.setup_s;
            if (eta <= c.t_end) {
              const lat = eta - t0;
              if (!best || lat < best.latency) best = { found: true, eta, latency: lat, hops: 1, contact_ids: [c.id], nodes: [srcId, dstId] };
            }
          }
        });
        if (best) result = best;
      }
      return result;
    }

    function kYenRoutes(srcId, dstId, t0, bundle_bytes, k) {
      const routes = [];
      const base = (config.routingAlgorithm === 'cgr-enhanced' || config.routingAlgorithm === 'auto')
        ? cgrEnhancedSearch(srcId, dstId, t0, bundle_bytes)
        : cgrClassicSearch(srcId, dstId, t0, bundle_bytes);

      if (!base.found) return routes;
      routes.push(base);

      for (let i = 1; i < k; i++) {
        const ref = routes[0];
        let added = false;

        for (let spur = 0; spur < ref.hops && !added; spur++) {
          const bannedId = ref.contact_ids[spur];
          const old = contactGraph;
          contactGraph = old.filter(c => c.id !== bannedId);

          const alt = (config.routingAlgorithm === 'cgr-enhanced' || config.routingAlgorithm === 'auto')
            ? cgrEnhancedSearch(srcId, dstId, t0, bundle_bytes)
            : cgrClassicSearch(srcId, dstId, t0, bundle_bytes);

          contactGraph = old;

          if (alt.found) {
            const isDup = routes.some(r =>
              r.hops === alt.hops &&
              r.contact_ids.length === alt.contact_ids.length &&
              r.contact_ids.every((id, j) => id === alt.contact_ids[j])
            );
            if (!isDup) { routes.push(alt); added = true; }
          }
        }
      }
      return routes;
    }

    // =============== ROUTE VISUALIZATION ===============
    function clearRoute() {
      routeEntities.forEach(e => viewer.entities.remove(e));
      routeEntities = [];
    }

    function visualizeRoute(route) {
      clearRoute();
      if (!route || !route.found) return;

      const idToContact = {};
      contactGraph.forEach(c => idToContact[c.id] = c);

      route.contact_ids.forEach(cid => {
        const c = idToContact[cid];
        const s1 = satellites.find(s => s.id === c.from);
        const s2 = satellites.find(s => s.id === c.to);
        if (!s1 || !s2) return;

        const ent = viewer.entities.add({
          polyline: {
            positions: new Cesium.CallbackProperty(() => {
              const t = simSeconds();
              const p1 = getSatellitePosition(s1.plane, s1.index, s1.meanAnomalyStart, s1.inclination, s1.raan, t);
              const p2 = getSatellitePosition(s2.plane, s2.index, s2.meanAnomalyStart, s2.inclination, s2.raan, t);
              return [p1, p2];
            }, false),
            width: 3.0,
            material: new Cesium.PolylineGlowMaterialProperty({
              glowPower: 0.25, color: Cesium.Color.fromCssColorString('#ffffff')
            })
          }
        });
        routeEntities.push(ent);
      });

      document.getElementById('routeLatency').textContent = `${route.latency.toFixed(2)} s`;
      document.getElementById('routeHops').textContent = `${route.hops}`;
    }

    function displayAlternativeRoutes(routes) {
      const div = document.getElementById('alternativeRoutes');
      div.innerHTML = '';
      routes.forEach((r, idx) => {
        const el = document.createElement('div');
        el.className = 'route-step';
        el.innerHTML = `<strong>Route ${idx+1}</strong> ‚Äî Hops: ${r.hops}, Latency: ${r.latency.toFixed(2)} s`;
        div.appendChild(el);
      });
    }

    // =============== METRICS & REPLAN ===============
    function updateMetrics() {
      const nowSec = simSeconds();
      const active = contactGraph.filter(c => nowSec >= c.t_start && nowSec < c.t_end).length;
      document.getElementById('activeContacts').textContent = active;
      const simEl = document.getElementById('simTimeMetric');
      if (simEl) simEl.textContent = `${nowSec.toFixed(1)} s`;
    }

    function replanRoute() {
      if (!sourceNode || !destNode || sourceNode.id === destNode.id) return;

      const t0 = simSeconds();
      const tStart = performance.now();

      let mode = document.getElementById('routingAlgorithm').value;
      if (mode === 'auto') {
        const actives = contactGraph.filter(c => t0 >= c.t_start && t0 < c.t_end).length;
        mode = (actives > Math.max(10, satellites.length / 2)) ? 'cgr-enhanced' : 'cgr-classic';
      }
      config.routingAlgorithm = mode;
      document.getElementById('activeAlgo').textContent =
        (mode === 'cgr-enhanced') ? 'CGR Enhanced' :
        (mode === 'cgr-classic') ? 'CGR Classic' : 'Auto';

      const bundleBytes = config.bundleSize;
      const result = (mode === 'cgr-enhanced') ? cgrEnhancedSearch(sourceNode.id, destNode.id, t0, bundleBytes)
                                               : cgrClassicSearch(sourceNode.id, destNode.id, t0, bundleBytes);

      const finalResult = result.found ? result : cgrEnhancedSearch(sourceNode.id, destNode.id, t0, bundleBytes);

      const tEnd = performance.now();
      document.getElementById('calcTime').textContent = `${(tEnd - tStart).toFixed(1)} ms`;

      currentRoute = finalResult.found ? finalResult : null;
      visualizeRoute(currentRoute);

      const k = config.kRoutes;
      const routes = kYenRoutes(sourceNode.id, destNode.id, t0, bundleBytes, k);
      if (routes.length === 0 && currentRoute) routes.push(currentRoute);
      displayAlternativeRoutes(routes);
    }

    // =============== BUTTONS ===============
    function changeSenderReceiver() {
      if (satellites.length < 2) return;
      const a = satellites[Math.floor(Math.random() * satellites.length)];
      let b = satellites[Math.floor(Math.random() * satellites.length)];
      if (a.id === b.id) b = satellites[(satellites.indexOf(a) + 1) % satellites.length];
      sourceNode = a; destNode = b;
      recolorSourceDest();
      replanRoute();
    }

    function toggleAnimation() { viewer.clock.shouldAnimate = !viewer.clock.shouldAnimate; }
    function resetView() { viewer.camera.flyHome(1.2); }

    // =============== LISTENERS ===============
    document.getElementById('satCount').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 9) / (36 - 9) * 100}%`);
      config.satCount = v;
      document.getElementById('satCountDisplay').textContent = v;
    });
    document.getElementById('satCount').addEventListener('change', () => {
      initConstellation(config.satCount, config.altitude);
      buildContactGraph(); replanRoute();
    });

    document.getElementById('altitude').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 400) / (1200 - 400) * 100}%`);
      config.altitude = v * 1000;
      document.getElementById('altDisplay').textContent = v;
    });
    document.getElementById('altitude').addEventListener('change', () => {
      initConstellation(config.satCount, config.altitude);
      buildContactGraph(); replanRoute();
    });

    document.getElementById('simSpeed').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 1) / (100 - 1) * 100}%`);
      config.simSpeed = v;
      document.getElementById('speedDisplay').textContent = `${v}x`;
      viewer.clock.multiplier = v;
    });

    document.getElementById('recalcFreq').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 1) / 9 * 100}%`);
      config.recalcFreq = v;
      document.getElementById('recalcDisplay').textContent = v;
    });

    document.getElementById('planningHorizon').addEventListener('change', (e) => {
      const v = parseInt(e.target.value, 10);
      config.planningHorizon = Math.max(5, Math.min(180, v)) * 60;
      buildContactGraph(); replanRoute();
    });

    document.getElementById('bundleSize').addEventListener('change', (e) => {
      config.bundleSize = Math.max(1, parseInt(e.target.value, 10)) * 1e6;
      replanRoute();
    });

    document.getElementById('kRoutes').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      e.target.style.setProperty('--value', `${(v - 1) / 9 * 100}%`);
      config.kRoutes = v;
      document.getElementById('kDisplay').textContent = v;
      replanRoute();
    });

    document.getElementById('routingAlgorithm').addEventListener('change', (e) => {
      config.routingAlgorithm = e.target.value;
      replanRoute();
    });

    document.getElementById('safeDistance').addEventListener('change', (e) => {
      const km = Math.max(1, Math.min(5000, parseInt(e.target.value, 10)));
      config.safeDistance = km * 1000;
    });

    // =============== CLOCK TICK LOOP ===============
    let lastRecalcSec = 0;
    let lastMetricsSec = 0;

    viewer.clock.onTick.addEventListener(() => {
      const t = simSeconds();

      if (t - lastMetricsSec > 0.25) {
        updateMetrics();
        updateContactWindowsList();
        lastMetricsSec = t;
      }

      detectCollisions();

      if (t - lastRecalcSec >= config.recalcFreq) {
        buildContactGraph();
        replanRoute();
        lastRecalcSec = t;
      }
    });

    // =============== INIT ===============
    function boot() {
      updateDisplayBadges();
      initConstellation(config.satCount, config.altitude);
      buildContactGraph();
      replanRoute();
      viewer.camera.flyHome(0);
    }
    boot();

    // Expose
    window.changeSenderReceiver = changeSenderReceiver;
    window.toggleAnimation = toggleAnimation;
    window.resetView = resetView;
    window.switchTab = switchTab;
    window.toggleBottomPanel = toggleBottomPanel;
  </script>
</body>
</html>
